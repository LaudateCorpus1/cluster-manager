// Code generated by go-swagger; DO NOT EDIT.

/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	//"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Cluster cluster
// swagger:model Cluster
type Cluster struct {

	// auth config Id
	AuthConfigID string `json:"authConfigId,omitempty"`

	// bmc cluster config
	BmcClusterConfig *BMCClusterConfig `json:"bmcClusterConfig,omitempty"`

	// cloud details
	CloudDetails *CloudDetails `json:"cloudDetails,omitempty"`

	// cloud type
	CloudType string `json:"cloudType,omitempty"`

	// desired state
	DesiredState string `json:"desiredState,omitempty"`

	// endpoints
	Endpoints map[string]string `json:"endpoints"`
	//Endpoints []*ClusterEndpoint `json:"endpoints"`

	// id
	ID string `json:"id,omitempty"`

	// k8 version
	K8Version string `json:"k8Version,omitempty"`

	// masters state
	MastersState string `json:"mastersState,omitempty"`

	// metadata
	Metadata *ClusterMetadata `json:"metadata,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// nodes state
	NodesState string `json:"nodesState,omitempty"`

	// resource owner Id
	ResourceOwnerID string `json:"resourceOwnerId,omitempty"`

	// state
	State string `json:"state,omitempty"`

	// state details
	StateDetails *StateDetails `json:"stateDetails,omitempty"`

	// tenant Id
	TenantID string `json:"tenantId,omitempty"`

	// tkm state
	TkmState string `json:"tkmState,omitempty"`

	// tkw state
	TkwState string `json:"tkwState,omitempty"`
}

// Validate validates this cluster
func (m *Cluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBmcClusterConfig(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCloudDetails(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateEndpoints(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMastersState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateNodesState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStateDetails(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTkmState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTkwState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) validateBmcClusterConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.BmcClusterConfig) { // not required
		return nil
	}

	if m.BmcClusterConfig != nil {

		if err := m.BmcClusterConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bmcClusterConfig")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateCloudDetails(formats strfmt.Registry) error {

	if swag.IsZero(m.CloudDetails) { // not required
		return nil
	}

	if m.CloudDetails != nil {

		if err := m.CloudDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cloudDetails")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateEndpoints(formats strfmt.Registry) error {

	if swag.IsZero(m.Endpoints) { // not required
		return nil
	}

	/*

	for i := 0; i < len(m.Endpoints); i++ {

		if swag.IsZero(m.Endpoints[i]) { // not required
			continue
		}

		if m.Endpoints[i] != nil {

			if err := m.Endpoints[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("endpoints" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}
	*/
	return nil
}

var clusterTypeMastersStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PendingState","Running","Succeeded","Failed","Unknown","Terminating","Terminated"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeMastersStatePropEnum = append(clusterTypeMastersStatePropEnum, v)
	}
}

const (
	// ClusterMastersStatePendingState captures enum value "PendingState"
	ClusterMastersStatePENDINGSTATE string = "PENDINGSTATE"
	// ClusterMastersStateRunning captures enum value "RUNNING"
	ClusterMastersStateRUNNING string = "RUNNING"
	// ClusterMastersStateSucceeded captures enum value "Succeeded"
	ClusterMastersStateSUCCEEDED string = "SUCCEEDED"
	// ClusterMastersStateFailed captures enum value "Failed"
	ClusterMastersStateFAILED string = "FAILED"
	// ClusterMastersStateUnknown captures enum value "Unknown"
	ClusterMastersStateUNKNOWN string = "UNKNOWN"
	// ClusterMastersStateTerminating captures enum value "Terminating"
	ClusterMastersStateTERMINATING string = "TERMINATING"
	// ClusterMastersStateTerminated captures enum value "Terminated"
	ClusterMastersStateTERMINATED string = "TERMINATED"
)

// prop value enum
func (m *Cluster) validateMastersStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, clusterTypeMastersStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateMastersState(formats strfmt.Registry) error {

	if swag.IsZero(m.MastersState) { // not required
		return nil
	}

	// value enum
	if err := m.validateMastersStateEnum("mastersState", "body", m.MastersState); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateMetadata(formats strfmt.Registry) error {

	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {

		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

var clusterTypeNodesStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["INITIALIZING","PROVISIONING","RUNNING","TERMINATING","TERMINATED","FAILING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeNodesStatePropEnum = append(clusterTypeNodesStatePropEnum, v)
	}
}

const (
	// ClusterNodesStateINITIALIZING captures enum value "INITIALIZING"
	ClusterNodesStateINITIALIZING string = "INITIALIZING"
	// ClusterNodesStatePROVISIONING captures enum value "PROVISIONING"
	ClusterNodesStatePROVISIONING string = "PROVISIONING"
	// ClusterNodesStateRUNNING captures enum value "RUNNING"
	ClusterNodesStateRUNNING string = "RUNNING"
	// ClusterNodesStateTERMINATING captures enum value "TERMINATING"
	ClusterNodesStateTERMINATING string = "TERMINATING"
	// ClusterNodesStateTERMINATED captures enum value "TERMINATED"
	ClusterNodesStateTERMINATED string = "TERMINATED"
	// ClusterNodesStateFAILING captures enum value "FAILING"
	ClusterNodesStateFAILING string = "FAILING"
)

// prop value enum
func (m *Cluster) validateNodesStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, clusterTypeNodesStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateNodesState(formats strfmt.Registry) error {

	if swag.IsZero(m.NodesState) { // not required
		return nil
	}

	// value enum
	if err := m.validateNodesStateEnum("nodesState", "body", m.NodesState); err != nil {
		return err
	}

	return nil
}

var clusterTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["INITIALIZING","PROVISIONING","RUNNING","TERMINATING","TERMINATED","FAILING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeStatePropEnum = append(clusterTypeStatePropEnum, v)
	}
}

const (
	// ClusterStateINITIALIZING captures enum value "INITIALIZING"
	ClusterStateINITIALIZING string = "INITIALIZING"
	// ClusterStatePROVISIONING captures enum value "PROVISIONING"
	ClusterStatePROVISIONING string = "PROVISIONING"
	// ClusterStateRUNNING captures enum value "RUNNING"
	ClusterStateRUNNING string = "RUNNING"
	// ClusterStateTERMINATING captures enum value "TERMINATING"
	ClusterStateTERMINATING string = "TERMINATING"
	// ClusterStateTERMINATED captures enum value "TERMINATED"
	ClusterStateTERMINATED string = "TERMINATED"
	// ClusterStateFAILING captures enum value "FAILING"
	ClusterStateFAILING string = "FAILING"
)

// prop value enum
func (m *Cluster) validateStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, clusterTypeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateState(formats strfmt.Registry) error {

	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateStateDetails(formats strfmt.Registry) error {

	if swag.IsZero(m.StateDetails) { // not required
		return nil
	}

	if m.StateDetails != nil {

		if err := m.StateDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stateDetails")
			}
			return err
		}
	}

	return nil
}

var clusterTypeTkmStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["PendingState","Running","Succeeded","Failed","Unknown","Terminating","Terminated"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeTkmStatePropEnum = append(clusterTypeTkmStatePropEnum, v)
	}
}

const (
	// ClusterTkmStatePendingState captures enum value "PendingState"
	ClusterTkmStatePendingState string = "PendingState"
	// ClusterTkmStateRunning captures enum value "Running"
	ClusterTkmStateRunning string = "Running"
	// ClusterTkmStateSucceeded captures enum value "Succeeded"
	ClusterTkmStateSucceeded string = "Succeeded"
	// ClusterTkmStateFailed captures enum value "Failed"
	ClusterTkmStateFailed string = "Failed"
	// ClusterTkmStateUnknown captures enum value "Unknown"
	ClusterTkmStateUnknown string = "Unknown"
	// ClusterTkmStateTerminating captures enum value "Terminating"
	ClusterTkmStateTerminating string = "Terminating"
	// ClusterTkmStateTerminated captures enum value "Terminated"
	ClusterTkmStateTerminated string = "Terminated"
)

// prop value enum
func (m *Cluster) validateTkmStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, clusterTypeTkmStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateTkmState(formats strfmt.Registry) error {

	if swag.IsZero(m.TkmState) { // not required
		return nil
	}

	// value enum
	if err := m.validateTkmStateEnum("tkmState", "body", m.TkmState); err != nil {
		return err
	}

	return nil
}

var clusterTypeTkwStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["INITIALIZING","PROVISIONING","RUNNING","TERMINATING","TERMINATED","FAILING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterTypeTkwStatePropEnum = append(clusterTypeTkwStatePropEnum, v)
	}
}

const (
	// ClusterTkwStateINITIALIZING captures enum value "INITIALIZING"
	ClusterTkwStateINITIALIZING string = "INITIALIZING"
	// ClusterTkwStatePROVISIONING captures enum value "PROVISIONING"
	ClusterTkwStatePROVISIONING string = "PROVISIONING"
	// ClusterTkwStateRUNNING captures enum value "RUNNING"
	ClusterTkwStateRUNNING string = "RUNNING"
	// ClusterTkwStateTERMINATING captures enum value "TERMINATING"
	ClusterTkwStateTERMINATING string = "TERMINATING"
	// ClusterTkwStateTERMINATED captures enum value "TERMINATED"
	ClusterTkwStateTERMINATED string = "TERMINATED"
	// ClusterTkwStateFAILING captures enum value "FAILING"
	ClusterTkwStateFAILING string = "FAILING"
)

// prop value enum
func (m *Cluster) validateTkwStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, clusterTypeTkwStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *Cluster) validateTkwState(formats strfmt.Registry) error {

	if swag.IsZero(m.TkwState) { // not required
		return nil
	}

	// value enum
	if err := m.validateTkwStateEnum("tkwState", "body", m.TkwState); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Cluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Cluster) UnmarshalBinary(b []byte) error {
	var res Cluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
